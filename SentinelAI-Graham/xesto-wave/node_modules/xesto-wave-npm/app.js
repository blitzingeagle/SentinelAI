import Leap from "leapjs";
import degrees from "radians-degrees";

import URLS from "./constants/urls.json";
const io = require("socket.io-client");
const API_BASE_URL = URLS.API_BASE_URL;
const socket = io(API_BASE_URL);

import hackerModeGetAuthToken from "./src/lib/requests/hackerModeGetAuthToken.js";

const MIN_AMOUNT_OF_FRAMES = 17;
const FINGER_VELOCITY_LIMIT = 27;
const PALM_VELOCITY_LIMIT = 20;


export function fingerIsMoving(finger) {
  const tipVelocity = finger.tipVelocity;
  const maxTipVelocity = Math.max(Math.abs(tipVelocity[0]), Math.abs(tipVelocity[1]), Math.abs(tipVelocity[2]));
  return maxTipVelocity >= FINGER_VELOCITY_LIMIT;
}

export const prepareFrame = frame => {
  const oneHand = frame.hands[0];
  let fingersPositionsArray = [];
  oneHand.fingers.forEach(finger => {
    fingersPositionsArray = fingersPositionsArray.concat( finger.dipPosition );
  });

  let preparedFrame = [];
  preparedFrame = preparedFrame
    .concat(oneHand.palmPosition)
    .concat(degrees(oneHand.pitch()))
    .concat(degrees(oneHand.roll()))
    .concat(degrees(oneHand.yaw()))
    .concat(fingersPositionsArray);
  return preparedFrame;
}

export function frameNotValid(frame) {
  const firstHand = frame.hands[0];
  const secondHand = frame.hands[1];
  if (firstHand && secondHand && firstHand.fingers.length === 0 && secondHand.fingers.length === 10) {
    return true;
  }
  return false;
}

export function palmMoving(palmVelocity) {
  const maxPalmVelocity = Math.max(Math.abs(palmVelocity[0]), Math.abs(palmVelocity[1]), Math.abs(palmVelocity[2]));
  return maxPalmVelocity >= PALM_VELOCITY_LIMIT;
}

export function gestureHasEnoughFrames(framesInGesture) {
  return framesInGesture >= MIN_AMOUNT_OF_FRAMES;
}

function recognizeGesture(gesture, token) {
  socket.emit("RECOGNIZE_GESTURE", {
    data: gesture,
    jwt: token
  });
}

const buildController = (token, options) => {
  const controller = new Leap.Controller({ frameEventName: "animationFrame" });
  let motionDetectionFrames = [];


  Leap.plugin("xesto-wave", function (options) {
    socket.on("GESTURE_RECOGNIZED", ( classification ) => {
      const gestureName = classification.name;
      const conf = classification.confidence;
      console.log(classification);
      if ( conf >= 0.6 ) {
        return this.emit( gestureName, conf );
      }
    });

    return {
      frame: (frame) => {
        const firstHand = frame.hands[0];
        const handsOnScreen = firstHand !== undefined;

        if (handsOnScreen && frameNotValid(frame)) {
          return;
        }
        if (handsOnScreen) {
          if (palmMoving(firstHand.palmVelocity) || firstHand.fingers.some(fingerIsMoving)) {
            motionDetectionFrames.push(prepareFrame(frame));
            return;
          }
        }
        //runs when hand is not moving
        if (handsOnScreen && gestureHasEnoughFrames(motionDetectionFrames.length + 1)) {
          motionDetectionFrames.push(prepareFrame(frame));
          recognizeGesture(motionDetectionFrames, token);
          motionDetectionFrames = [];
        } else if (!handsOnScreen && gestureHasEnoughFrames(motionDetectionFrames.length)) {
          recognizeGesture(motionDetectionFrames, token);
          motionDetectionFrames = [];
        } else if (motionDetectionFrames.length > 0) {
          motionDetectionFrames = [];
        }
      }
    }
  });

  controller.use("xesto-wave");
  return controller;
}


const xesto = (apikey) => {
  return { 
   connect: (options) => {
      return hackerModeGetAuthToken(apikey).then(token => {
        return buildController(token, options);
      });
    }
  }
}

export default xesto;
